&lt;?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>langchain on Fellipe Gomes - Data Science Blog</title>
    <link>https://gomesfellipe.github.io/tags/langchain/</link>
    <description>√öltimos posts sobre Data Science, Machine Learning e R</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <managingEditor>gomes.fellipe1@gmail.com (Fellipe Carvalho Gomes)</managingEditor>
    <webMaster>gomes.fellipe1@gmail.com (Fellipe Carvalho Gomes)</webMaster>
    <lastBuildDate>Wed, 26 Nov 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://gomesfellipe.github.io/tags/langchain/" rel="self" type="application/rss+xml" />
    <item>
      <title>Agente para an√°lise interpretativa de liga√ß√µes de telemarketing</title>
      <link>https://gomesfellipe.github.io/post/2025-10-26-telemarketing-agent/</link>
      <pubDate>Wed, 26 Nov 2025 00:00:00 +0000</pubDate>
      <author>gomes.fellipe1@gmail.com (Fellipe Carvalho Gomes)</author>
      <guid>https://gomesfellipe.github.io/post/2025-10-26-telemarketing-agent/</guid>
      <description>Neste post vamos criar um agente para extrair insights estruturados de liga√ß√µes de telemarketing, transformando grava√ß√µes de √°udio em um relat√≥rio anal√≠tico</description>
      <content:encoded>&lt;![CDATA[
        


<div id="por-que-analisar-liga√ß√µes-de-telemarketing-com-ia" class="section level1">
<h1>Por que analisar liga√ß√µes de telemarketing com IA?</h1>
<p>Quem nunca recebeu aquela liga√ß√£o de telemarketing no momento mais inoportuno? Seja oferecendo um cart√£o de cr√©dito, cobrando uma d√≠vida ou tentando vender internet, essas liga√ß√µes fazem parte do nosso cotidiano. Mas voc√™ j√° parou para pensar na quantidade de informa√ß√µes valiosas que existem nessas conversas?</p>
<p>Para empresas que operam call centers, analisar essas liga√ß√µes manualmente √© uma tarefa herc√∫lea. Imagine ter que ouvir centenas ou milhares de liga√ß√µes por dia para:</p>
<ul>
<li>Avaliar a qualidade do atendimento</li>
<li>Identificar problemas recorrentes</li>
<li>Detectar poss√≠veis fraudes</li>
<li>Treinar equipes com base em casos reais</li>
<li>Garantir compliance e conformidade legal</li>
</ul>
</div>
<div id="o-desafio-vai-al√©m-da-transcri√ß√£o-de-textos" class="section level1">
<h1>O desafio vai al√©m da transcri√ß√£o de textos</h1>
<p>Analisar liga√ß√µes de telemarketing apresenta desafios que v√£o muito al√©m da simples transcri√ß√£o de √°udio para texto. O grande volume de dados, a necessidade de identificar corretamente quem est√° falando em √°udios mono (onde todas as vozes est√£o em um √∫nico canal) e a extra√ß√£o de informa√ß√µes relevantes a partir de conversas n√£o estruturadas tornam o processo complexo e exigem solu√ß√µes especializadas.</p>
<p>Entre os principais obst√°culos t√©cnicos est√£o: converter fala em texto com precis√£o mesmo diante de sotaques e ru√≠dos, diarizar os speakers (diferenciar atendente e cliente), transformar transcri√ß√µes em dados estruturados (como sentimento, tipo de liga√ß√£o e problemas), al√©m de garantir escalabilidade para processar milhares de liga√ß√µes de forma eficiente, preferencialmente utilizando recursos como GPU.</p>
</div>
<div id="solu√ß√£o-t√©cnica-abordagem-em-4-etapas" class="section level1">
<h1>Solu√ß√£o t√©cnica: Abordagem em 4 etapas</h1>
<p>Enquanto estudava para trablhar em um projeto com desafio semelhante, desenvolvi um pipeline em Python integrando tr√™s tecnologias de ponta, com foco em solu√ß√µes gratuitas para estudo e prova de conceito. O projeto abrangeu desde a aquisi√ß√£o das liga√ß√µes at√© a extra√ß√£o de insights estruturados, utilizando recursos pagos em ambiente de produ√ß√£o, mas priorizando ferramentas acess√≠veis para pesquisa e valida√ß√£o.</p>
<center>
<div style="width: 90%;">
<p><img src="/post/2025-10-26-telemarketing-agent/workflow.png" alt="agent telemarketing analysis workflow" style="width: 100%;"></p>
</div>
<p style="text-align: center; font-style: italic;">
Fluxo de trabalho completo
</p>
</center>
<p>As etapas principais foram:</p>
<ol style="list-style-type: decimal">
<li><strong>Coleta e prepara√ß√£o dos dados</strong>: Download e segmenta√ß√£o dos √°udios com <code>yt_dlp</code>, <code>pydub</code> e <code>ffmpeg</code>.</li>
<li><strong>Transcri√ß√£o dos √°udios</strong>:
<ul>
<li><strong>Diariza√ß√£o/segmenta√ß√£o por locutor</strong>: Utilizando o modelo de diariza√ß√£o do <a href="https://github.com/pyannote/pyannote-audio">Pyannote.audio</a></li>
<li><strong>Reconhecimento autom√°tico de fala (ASR)</strong>: Modelos gratuitos do <a href="https://openai.com/research/whisper">Whisper da OpenAI</a> hospedados na Hugging Face.</li>
</ul></li>
<li><strong>An√°lise interpretativa</strong>: Extra√ß√£o de informa√ß√µes estruturadas com GPT da OpenAI e o framework <a href="https://python.langchain.com/">LangChain</a> .</li>
<li><strong>Abordagem anal√≠tica</strong>: Explora√ß√£o dos dados, cria√ß√£o de dashboards e, eventualmente, constru√ß√£o de modelos preditivos (por exemplo, prever se a venda foi conclu√≠da).</li>
</ol>
<p>Tecnologias Utilizadas:</p>
<ul>
<li><strong><a href="https://openai.com/research/whisper">Whisper (OpenAI)</a></strong>: Modelo state-of-the-art para transcri√ß√£o de √°udio</li>
<li><strong><a href="https://github.com/pyannote/pyannote-audio">Pyannote.audio</a></strong>: Framework especializado em diariza√ß√£o de speakers</li>
<li><strong><a href="https://python.langchain.com/">LangChain</a></strong>: Framework de LLMs para extra√ß√£o estruturada</li>
<li><strong>Python</strong>: Orquestra√ß√£o de todo o pipeline</li>
<li><strong>Google Colab</strong>: Ambiente com GPU gratuita</li>
</ul>
<p>Este post vai cobrir apenas a terceira etapa do pipeline: a an√°lise interpretativa das transcri√ß√µes. Vamos mostrar como transformar o texto bruto das liga√ß√µes em informa√ß√µes estruturadas e acion√°veis usando agentes de GenAI, detalhando o processo de extra√ß√£o autom√°tica de sentimentos, problemas, resultados e respostas criativas a partir das conversas.</p>
<div id="dados-utilizados" class="section level2">
<h2>Dados utilizados</h2>
<p>Para este experimento, selecionei alguns v√≠deos de esquetes de com√©dia sobre telemarketing <a href="https://www.youtube.com/watch?v=AJVpdNuLdv4">dispon√≠veis no YouTube</a> e extra√≠ um arquivo de √°udio para cada liga√ß√£o, segmentando as conversas individualmente. Veja um exemplo:</p>
<center>
<audio controls>
<source src="/post/2025-10-26-telemarketing-agent/audio_00.mp3" type="audio/mpeg">
Seu navegador n√£o suporta √°udio.
</audio>
</center>
<p>A transcri√ß√£o dos √°udios foi realizada utilizando <a href="https://huggingface.co/openai/whisper-large-v3">Whisper</a> para reconhecimento de fala e <a href="https://huggingface.co/pyannote/speaker-diarization-3.1">Pyannote</a> para diariza√ß√£o dos locutores. Desenvolvi um script que integra essas ferramentas utilizando recursos de GPU em ambientes como Kaggle e Google Colab, o que permite processar grandes volumes de √°udio gratuitamente.</p>
<p>Veja como ficou o resultado ap√≥s a atribui√ß√£o dos speakers no p√≥s-processamento:</p>
<pre><code>SPEAKER_00: Eu gostaria de falar com o Eliel Clayton de Oliveira.
SPEAKER_01: Ele n√£o t√°, t√° pra fazenda. Liga amanh√£, ele deixou o celular.
SPEAKER_00: Ah, tudo bem. Eu posso deixar o telefone pra contato com ele no internet? Quem √© voc√™? Voc√™ √© namorada dele? N√£o, eu sou uma da assessoria de cobran√ßa.
SPEAKER_01: Da onde? Da outra fazenda? Da fazenda Bonan√ßa?
SPEAKER_00: N√£o, senhora. Eu sou da assessoria da beb√™ financeira. Ah, estavam ent√£o da Bahia, n√©? Vou falar pra ele que ligaram pra ele ent√£o, t√°?
SPEAKER_01: √â da beb√™ financeira, assessoria da beb√™ financeira.
SPEAKER_00: Voc√™ teve um beb√™ com ele? Aonde voc√™ t√°, minha filha? N√£o, senhora, assessoria da beb√™ financeira.
SPEAKER_01: Est√£o falando que tem uma mulher que tem um beb√™ do Eliel.
SPEAKER_00: Acho melhor voc√™ ligar amanh√£ ent√£o, pra ver com ele, pra ver o DNA.</code></pre>
<div class="w3-panel w3-pale-yellow w3-border">
<p>¬† ‚ö†Ô∏è Naturalmente, todo modelo de transcri√ß√£o apresenta uma taxa de acerto que pode variar de acordo com a qualidade do √°udio, sotaques e presen√ßa de ru√≠dos.</p>
</div>
<p>Neste post o foco est√° na constru√ß√£o do agente de an√°lise interpretativa, assumindo que as transcri√ß√µes j√° est√£o dispon√≠veis e prontas para uso. Na vers√£o do projeto que foi para produ√ß√£o, utilizamos uma ferramenta diferente para a etapa de transcri√ß√£o, mas como prova de conceito at√© que achei o resultado bem descente.</p>
</div>
</div>
<div id="an√°lise-estruturada-com-agente-de-genai" class="section level1">
<h1>An√°lise estruturada com Agente de GenAI</h1>
<p>√â aqui que a m√°gica realmente acontece: com o poder do <a href="https://www.langchain.com/">LangChain</a> e o recurso de <strong>Structured Output</strong>, conseguimos transformar transcri√ß√µes brutas de liga√ß√µes em dados estruturados e acion√°veis. Em vez de apenas ler textos longos e desorganizados, extra√≠mos automaticamente sentimentos, problemas, resultados e at√© respostas criativas. Tudo pronto para an√°lise, visualiza√ß√£o ou integra√ß√£o com sistemas de neg√≥cio.</p>
<p>A ideia central se baseia no conceito de sa√≠da estruturada (<a href="https://pydantic-docs.helpmanual.io/">Pydantic</a> models) para fornecer ferramentas que for√ßam o modelo a devolver um JSON consistente que depois √© facilmente consumido por pipelines e dashboards.</p>
<details>
<summary>
<b>Schema Pydantic <i>(Ver c√≥digo)</i></b>
</summary>
<pre class="python"><code># An√°lise de Sentimento
class SentimentoLigacao(BaseModel):
    &quot;&quot;&quot;An√°lise de sentimento da liga√ß√£o.&quot;&quot;&quot;
    sentimento_cliente: Literal[&quot;positivo&quot;, &quot;neutro&quot;, &quot;negativo&quot;, &quot;irritado&quot;]
    sentimento_atendente: Literal[&quot;profissional&quot;, &quot;neutro&quot;, &quot;agressivo&quot;, &quot;impaciente&quot;]
    nivel_conflito: Literal[&quot;baixo&quot;, &quot;medio&quot;, &quot;alto&quot;]

# Informa√ß√µes da Liga√ß√£o
class InformacaoLigacao(BaseModel):
  &quot;&quot;&quot;Informa√ß√µes extra√≠das da liga√ß√£o.&quot;&quot;&quot;
  tipo_ligacao: Literal[&quot;cobranca&quot;, &quot;oferta_produto&quot;, &quot;suporte&quot;, &quot;pesquisa&quot;, &quot;fraude&quot;]
  empresa_mencionada: Optional[str] = None
  produto_servico: Optional[str] = None
  resultado_ligacao: Literal[&quot;sucesso&quot;, &quot;recusa&quot;, &quot;desligou&quot;, &quot;nao_resolvido&quot;, &quot;fraude_detectada&quot;]
  cliente_interessado: bool

# Identifica√ß√£o de Problemas
class ProblemaIdentificado(BaseModel):
    &quot;&quot;&quot;Problemas identificados na liga√ß√£o.&quot;&quot;&quot;
    tem_problema: bool
    tipo_problema: Optional[Literal[&quot;cobranca_indevida&quot;, &quot;cancelamento&quot;,
                                    &quot;atendimento_ruim&quot;, &quot;fraude&quot;, &quot;outro&quot;]] = None
    descricao_problema: Optional[str] = None
    requer_followup: bool

# Respostas Criativas
class RespostasCriativas(BaseModel):
    &quot;&quot;&quot;Respostas criativas ou inusitadas do cliente.&quot;&quot;&quot;
    teve_resposta_criativa: bool
    tipo_resposta: Optional[Literal[&quot;humor&quot;, &quot;desculpa_criativa&quot;,
                                    &quot;contra_ataque&quot;, &quot;confusao_proposital&quot;]] = None
    citacao: Optional[str] = None

# Schema agregador: um √∫nico resultado que engloba todos
class RelatorioLigacao(BaseModel):
    &quot;&quot;&quot;Relat√≥rio consolidado da liga√ß√£o. Preencha apenas os blocos aplic√°veis.&quot;&quot;&quot;
    sentimento: Optional[SentimentoLigacao] = None
    informacao: Optional[InformacaoLigacao] = None
    problema: Optional[ProblemaIdentificado] = None
    respostas_criativas: Optional[RespostasCriativas] = None</code></pre>
</details>
<p>Para criar o agente de an√°lise interpretativa, encapsulamos toda a configura√ß√£o do modelo de linguagem, defindo o schema de sa√≠da estruturada e estabelecendo as instru√ß√µes para que o agente atue como um verdadeiro especialista em liga√ß√µes de telemarketing. Com essa abordagem, garantimos que apenas informa√ß√µes realmente presentes na transcri√ß√£o sejam extra√≠das, tornando o processo robusto, audit√°vel e pronto para uso em escala, ou seja, para prot√≥tipos ou aplica√ß√µes em produ√ß√£o.</p>
<p>Instanciando o agente (exemplo)</p>
<pre class="python"><code>def instance_agent(api_key: str):
    model = ChatOpenAI(model=&quot;gpt-4o&quot;, api_key=api_key, temperature=0)

    agent = create_agent(
        model=model,
        tools=[],
        response_format=ToolStrategy(
            schema=RelatorioLigacao,
            handle_errors=True
        ),
        system_prompt=(
            &quot;Voc√™ √© um especialista em an√°lise de liga√ß√µes de telemarketing.\n&quot;
            &quot;Dado uma transcri√ß√£o, preencha somente os blocos do relat√≥rio que fizerem sentido.\n&quot;
            &quot;- Se n√£o houver problema, deixe &#39;problema&#39; como null.\n&quot;
            &quot;- Se n√£o houver respostas criativas, deixe &#39;respostas_criativas&#39; como null.\n&quot;
            &quot;- Seja conservador: s√≥ preencha quando tiver evid√™ncia no texto.&quot;
        ),
    )
    return agent

agent = instance_agent(api_key=OPENAI_API_KEY)

result = agent.invoke({
    &quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: transcriptions[&#39;audio_00&#39;]}]
})

result[&quot;structured_response&quot;].model_dump()</code></pre>
<p>Veja qual foi a sa√≠da obtida aplicando no nosso exemplo de √°udio:</p>
<pre class="text"><code>{
 &#39;sentimento&#39;: {
   &#39;sentimento_cliente&#39;: &#39;irritado&#39;,
   &#39;sentimento_atendente&#39;: &#39;impaciente&#39;,
   &#39;nivel_conflito&#39;: &#39;alto&#39;
 },
 &#39;informacao&#39;: {
   &#39;tipo_ligacao&#39;: &#39;cobranca&#39;,
   &#39;empresa_mencionada&#39;: None,
   &#39;produto_servico&#39;: None,
   &#39;resultado_ligacao&#39;: &#39;nao_resolvido&#39;,
   &#39;cliente_interessado&#39;: False
 },
 &#39;problema&#39;: None,
 &#39;respostas_criativas&#39;: {
   &#39;teve_resposta_criativa&#39;: True,
   &#39;tipo_resposta&#39;: &#39;humor&#39;,
   &#39;citacao&#39;: &#39;Eu agora, eu t√¥ tomando √© uma Heineken, uma hora dessa. T√° entendendo?&#39;
 }
}</code></pre>
<details>
<summary>
Loop para processar todos os √°udios <i>(Ver c√≥digo)</i>
</summary>
<pre class="python"><code>extractions = {}
for file_name, transcription in transcriptions.items():
    analysis = agent.invoke({&quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: transcription}]})
    structured = analysis.get(&quot;structured_response&quot;)
    extracted = structured.model_dump() if structured is not None else None
    extractions[file_name] = extracted
    # Salvar cache da execu√ß√£o
    with open(os.path.join(path_extractions, f&quot;{file_name}.json&quot;), &quot;w&quot;, encoding=&quot;utf-8&quot;) as fh:
        json.dump(extracted, fh, ensure_ascii=False, indent=2)</code></pre>
</details>
<p></br></p>
</div>
<div id="insights-estruturados" class="section level1">
<h1>Insights estruturados</h1>
Ap√≥s processar todos os √°udios podemos criar um dashboard que transforma as extra√ß√µes em KPIs acion√°veis, permitindo visualizar rapidamente m√©tricas como taxa de liga√ß√µes n√£o resolvidas, distribui√ß√£o dos tipos de liga√ß√£o, n√≠veis de conflito, frequ√™ncia de respostas criativas e outros indicadores essenciais para tomada de decis√£o e melhoria cont√≠nua dos processos.
<details>
<summary>
<i>Ver c√≥digo do Dashboard</i>
</summary>
<pre class="python"><code>import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.patches import Rectangle
import numpy as np

# criar DataFrame a partir do dicion√°rio de extra√ß√µes
df = pd.DataFrame.from_dict(extractions, orient=&#39;index&#39;)

# garantir que campos nulos sejam tratados como dicts vazios para normaliza√ß√£o
for col in [&#39;sentimento&#39;, &#39;informacao&#39;, &#39;problema&#39;, &#39;respostas_criativas&#39;]:
  df[col] = df[col].apply(lambda x: x if isinstance(x, dict) else {})

# normalizar cada bloco e juntar
sent_df = pd.json_normalize(df[&#39;sentimento&#39;]).add_prefix(&#39;sentimento_&#39;)
info_df = pd.json_normalize(df[&#39;informacao&#39;]).add_prefix(&#39;informacao_&#39;)
prob_df = pd.json_normalize(df[&#39;problema&#39;]).add_prefix(&#39;problema_&#39;)
resp_df = pd.json_normalize(df[&#39;respostas_criativas&#39;]).add_prefix(&#39;respostas_&#39;)

df_extractions = pd.concat([sent_df, info_df, prob_df, resp_df], axis=1)
df_extractions.index = df.index
df_extractions.index.name = &#39;file&#39;
df_extractions.reset_index(inplace=True)

# Configurar estilo
sns.set_style(&quot;white&quot;)
plt.rcParams.update({
  &#39;figure.facecolor&#39;: &#39;white&#39;,
  &#39;axes.facecolor&#39;: &#39;white&#39;,
  &#39;savefig.facecolor&#39;: &#39;white&#39;
})
sns.set_palette(&quot;husl&quot;)

# Criar figura com subplots
fig = plt.figure(figsize=(14, 12))
gs = fig.add_gridspec(4, 4, hspace=0.4, wspace=0.4)

# Cores personalizadas
colors_main = [&#39;#FF6B6B&#39;, &#39;#4ECDC4&#39;, &#39;#45B7D1&#39;, &#39;#FFA07A&#39;, &#39;#98D8C8&#39;, &#39;#F7DC6F&#39;]
colors_sentiment = {&#39;neutro&#39;: &#39;#95E1D3&#39;, &#39;irritado&#39;: &#39;#F38181&#39;, &#39;profissional&#39;: &#39;#4A90E2&#39;}
colors_conflict = {&#39;baixo&#39;: &#39;#A8E6CF&#39;, &#39;medio&#39;: &#39;#FFD93D&#39;, &#39;alto&#39;: &#39;#FF6B6B&#39;}

# ============= T√çTULO PRINCIPAL =============
fig.suptitle(&#39;An√°lise de Liga√ß√µes de Telemarketing com Agent&#39;,
             fontsize=28, fontweight=&#39;bold&#39;, y=0.9)

# ============= 1. M√âTRICAS PRINCIPAIS (agora vem primeiro) =============
ax7 = fig.add_subplot(gs[0, :])
ax7.axis(&#39;off&#39;)

# Calcular m√©tricas
total_ligacoes = len(df_extractions)
taxa_criatividade = (df_extractions[&#39;respostas_teve_resposta_criativa&#39;].sum() / total_ligacoes) * 100
taxa_irritacao = (df_extractions[&#39;sentimento_sentimento_cliente&#39;] == &#39;irritado&#39;).sum() / total_ligacoes * 100
taxa_nao_resolvido = (df_extractions[&#39;informacao_resultado_ligacao&#39;] == &#39;nao_resolvido&#39;).sum() / total_ligacoes * 100
taxa_conflito_alto = (df_extractions[&#39;sentimento_nivel_conflito&#39;] == &#39;alto&#39;).sum() / total_ligacoes * 100

# Criar caixas de m√©tricas
metrics = [
    (&#39;Total de Liga√ß√µes&#39;, f&#39;{total_ligacoes}&#39;, &#39;#4A90E2&#39;),
    (&#39;Taxa de Criatividade&#39;, f&#39;{taxa_criatividade:.1f}%&#39;, &#39;#4ECDC4&#39;),
    (&#39;Taxa de Irrita√ß√£o&#39;, f&#39;{taxa_irritacao:.1f}%&#39;, &#39;#FF6B6B&#39;),
    (&#39;N√£o Resolvidos&#39;, f&#39;{taxa_nao_resolvido:.1f}%&#39;, &#39;#FFA07A&#39;),
    (&#39;Conflito Alto&#39;, f&#39;{taxa_conflito_alto:.1f}%&#39;, &#39;#F38181&#39;)
]

x_positions = np.linspace(0.05, 0.85, len(metrics))
for i, (label, value, color) in enumerate(metrics):
    rect = Rectangle((x_positions[i], 0.25), 0.15, 0.5,
                     facecolor=color, linewidth=3,
                     transform=ax7.transAxes, zorder=2)
    ax7.add_patch(rect)

    ax7.text(x_positions[i] + 0.075, 0.58, value,
             ha=&#39;center&#39;, va=&#39;center&#39;, fontsize=22, fontweight=&#39;bold&#39;,
             color=&#39;white&#39;, transform=ax7.transAxes, zorder=3)
    ax7.text(x_positions[i] + 0.075, 0.18, label,
             ha=&#39;center&#39;, va=&#39;center&#39;, fontsize=11, fontweight=&#39;bold&#39;,
             transform=ax7.transAxes, zorder=3, wrap=True)

# ============= 2. SENTIMENTO DO CLIENTE =============
ax1 = fig.add_subplot(gs[1, 0:2])
sentimento_counts = df_extractions[&#39;sentimento_sentimento_cliente&#39;].value_counts()
# usar cinza para &quot;neutro&quot; (case-insensitive), caso contr√°rio usar palette existente
neutral_color = &#39;#B0B0B0&#39;
colors_sent = [
  neutral_color if str(x).strip().lower() == &#39;neutro&#39; else colors_sentiment.get(x, &#39;#95E1D3&#39;)
  for x in sentimento_counts.index
]
sent_labels = [str(x).replace(&#39;_&#39;, &#39; &#39;).upper() for x in sentimento_counts.index]
bars1 = ax1.bar(sent_labels, sentimento_counts.values, color=colors_sent, linewidth=2)
ax1.set_title(&#39;Sentimento do Cliente&#39;, fontsize=16, fontweight=&#39;bold&#39;, pad=15)
ax1.set_ylabel(&#39;&#39;, fontsize=12, fontweight=&#39;bold&#39;)
ax1.set_xlabel(&#39;&#39;, fontsize=12, fontweight=&#39;bold&#39;)
for bar in bars1:
  height = bar.get_height()
  ax1.text(bar.get_x() + bar.get_width()/2., height,
     f&#39;{int(height)}&#39;,
     ha=&#39;center&#39;, va=&#39;bottom&#39;, fontsize=14, fontweight=&#39;bold&#39;)
ax1.grid(axis=&#39;y&#39;, alpha=0.3)
# aumentar limite do eixo y em 5%
max_h1 = max(bar.get_height() for bar in bars1)
ax1.set_ylim(0, max_h1 * 1.15)

# ============= 3. N√çVEL DE CONFLITO =============
ax2 = fig.add_subplot(gs[1, 2:4])
conflito_counts = df_extractions[&#39;sentimento_nivel_conflito&#39;].value_counts()
colors_conf = [colors_conflict.get(x, &#39;#A8E6CF&#39;) for x in conflito_counts.index]
conf_labels = [str(x).replace(&#39;_&#39;, &#39; &#39;).upper() for x in conflito_counts.index]
bars2 = ax2.bar(conf_labels, conflito_counts.values, color=colors_conf, linewidth=2)
ax2.set_title(&#39;N√≠vel de Conflito&#39;, fontsize=16, fontweight=&#39;bold&#39;, pad=15)
ax2.set_ylabel(&#39;&#39;, fontsize=12, fontweight=&#39;bold&#39;)
ax2.set_xlabel(&#39;&#39;, fontsize=12, fontweight=&#39;bold&#39;)
for bar in bars2:
  height = bar.get_height()
  ax2.text(bar.get_x() + bar.get_width()/2., height,
       f&#39;{int(height)}&#39;,
       ha=&#39;center&#39;, va=&#39;bottom&#39;, fontsize=14, fontweight=&#39;bold&#39;)
ax2.grid(axis=&#39;y&#39;, alpha=0.3)
# aumentar limite do eixo y em 5%
if len(bars2) &gt; 0:
    max_h2 = max(bar.get_height() for bar in bars2)
    ax2.set_ylim(0, max_h2 * 1.15)

# ============= 4. TIPO DE LIGA√á√ÉO =============
ax3 = fig.add_subplot(gs[2, 0:2])
tipo_counts = df_extractions[&#39;informacao_tipo_ligacao&#39;].value_counts()
explode = [0.05 if i == 0 else 0 for i in range(len(tipo_counts))]
wedges, texts, autotexts = ax3.pie(tipo_counts.values, labels=tipo_counts.index, autopct=&#39;%1.1f%%&#39;,
                                     colors=colors_main, explode=explode, startangle=90,
                                     textprops={&#39;fontsize&#39;: 11})
ax3.set_title(&#39;Tipo de Liga√ß√£o&#39;, fontsize=16, fontweight=&#39;bold&#39;, pad=15)
for autotext in autotexts:
    autotext.set_color(&#39;white&#39;)
    autotext.set_fontsize(12)

# ============= 5. RESULTADO DA LIGA√á√ÉO =============
ax4 = fig.add_subplot(gs[2, 2:4])
resultado_counts = df_extractions[&#39;informacao_resultado_ligacao&#39;].value_counts()
res_labels = [str(x).replace(&#39;_&#39;, &#39; &#39;).upper() for x in resultado_counts.index]
bars4 = ax4.barh(res_labels, resultado_counts.values, color=colors_main[:len(resultado_counts)], linewidth=2)
ax4.set_title(&#39;Resultado da Liga√ß√£o&#39;, fontsize=16, fontweight=&#39;bold&#39;, pad=15)
ax4.set_xlabel(&#39;&#39;, fontsize=12, fontweight=&#39;bold&#39;)
for i, bar in enumerate(bars4):
  width = bar.get_width()
  ax4.text(width, bar.get_y() + bar.get_height()/2.,
       f&#39; {int(width)}&#39;,
       ha=&#39;left&#39;, va=&#39;center&#39;, fontsize=12, fontweight=&#39;bold&#39;)
ax4.grid(axis=&#39;x&#39;, alpha=0.3)

# ============= 6. RESPOSTAS CRIATIVAS =============
ax5 = fig.add_subplot(gs[3, 0:2])
criativas_counts = df_extractions[&#39;respostas_teve_resposta_criativa&#39;].fillna(False).astype(bool).value_counts()
counts5 = [criativas_counts.get(True, 0), criativas_counts.get(False, 0)]
labels5 = [&#39;Com Resposta\nCriativa&#39;, &#39;Sem Resposta\nCriativa&#39;]
colors_criativas = [&#39;#4ECDC4&#39;, &#39;#FF6B6B&#39;]

wedges5, texts5, autotexts5 = ax5.pie(counts5,
                    labels=labels5,
                    autopct=&#39;%1.1f%%&#39;,
                    colors=colors_criativas,
                    startangle=90,
                    textprops={&#39;fontsize&#39;: 12})
ax5.set_title(&#39;Respostas Criativas&#39;, fontsize=16, fontweight=&#39;bold&#39;, pad=15)
for autotext in autotexts5:
    autotext.set_color(&#39;white&#39;)
    autotext.set_fontsize(13)

# ============= 7. TIPOS DE RESPOSTA CRIATIVA =============
ax6 = fig.add_subplot(gs[3, 2:4])
tipo_resposta = df_extractions[&#39;respostas_tipo_resposta&#39;].dropna().value_counts()
tipo_labels = [str(x).replace(&#39;_&#39;, &#39; &#39;).upper() for x in tipo_resposta.index]
bars6 = ax6.barh(tipo_labels, tipo_resposta.values, color=colors_main[:len(tipo_resposta)], linewidth=2)
ax6.set_title(&#39;Tipos de Resposta Criativa&#39;, fontsize=16, fontweight=&#39;bold&#39;, pad=15)
ax6.set_xlabel(&#39;&#39;, fontsize=12, fontweight=&#39;bold&#39;)
for i, bar in enumerate(bars6):
  width = bar.get_width()
  ax6.text(width, bar.get_y() + bar.get_height()/2.,
       f&#39; {int(width)}&#39;,
       ha=&#39;left&#39;, va=&#39;center&#39;, fontsize=12, fontweight=&#39;bold&#39;)
ax6.grid(axis=&#39;x&#39;, alpha=0.3)

plt.show()</code></pre>
</details>
<p></br></p>
<center>
<div style="width: 90%;">
<p><img src="/post/2025-10-26-telemarketing-agent/dashboard.png" alt="agent telemarketing analysis workflow" style="width: 100%;"></p>
</div>
<p style="text-align: center; font-style: italic;">
Fluxo de trabalho completo
</p>
</center>
<div id="benef√≠cios-pr√°ticos-e-roi-mensur√°vel" class="section level2">
<h2>Benef√≠cios Pr√°ticos e ROI Mensur√°vel</h2>
<p>Para equipes que operam call centers e compliance, os ganhos s√£o claros:</p>
<ul>
<li><strong>Automa√ß√£o de QA</strong> (An√°lise de 100% das liga√ß√µes vs.¬†amostragem manual);</li>
<li>Redu√ß√£o dr√°stica no <strong>tempo de an√°lise</strong>;</li>
<li><strong>Detec√ß√£o precoce</strong> de problemas e fraudes;</li>
<li><strong>Treinamento</strong> baseado em casos reais e dados;</li>
<li>Evid√™ncias estruturadas para <strong>auditoria</strong>;</li>
<li>KPIs em tempo real e otimiza√ß√£o de scripts (<strong>A/B testing</strong>).</li>
</ul>
<p>Para empresas, isso significa decis√µes mais r√°pidas, menos custos com retrabalho e ROI tang√≠vel na opera√ß√£o.</p>
</div>
<div id="√©tica-licen√ßa-e-privacidade" class="section level2">
<h2>√âtica, licen√ßa e privacidade</h2>
<p>O dataset aqui usado √© p√∫blico (sketches de com√©dia) e foi apenas para fins pessoal/educacional. Para qualquer uso comercial:</p>
<ul>
<li>Verifique licen√ßa dos materiais originais;</li>
<li>Obtenha consentimento quando necess√°rio;</li>
<li>Anonimizar dados pessoais;</li>
<li>Adotar pr√°ticas de privacidade e conformidade (LGPD / GDPR).</li>
</ul>
</div>
</div>
<div id="conclus√£o-o-futuro-da-an√°lise-de-conversas" class="section level1">
<h1>Conclus√£o: O futuro da an√°lise de conversas</h1>
<p>O que come√ßou como um experimento com liga√ß√µes de telemarketing se transformou em uma demonstra√ß√£o poderosa do que √© poss√≠vel quando combinamos as melhores tecnologias de IA dispon√≠veis hoje. <strong>Em menos de 4 minutos, processamos 13 liga√ß√µes e extra√≠mos insights que levariam horas para analistas humanos descobrirem.</strong></p>
<div id="recursos-adicionais" class="section level2">
<h2>Recursos adicionais</h2>
<p>Tutoriais Complementares:</p>
<ul>
<li><a href="https://gomesfellipe.github.io/post/2025-05-04-bitcoin-agent/">Meu post sobre Agentes Multiagente</a> - LangChain em a√ß√£o</li>
<li><a href="https://gomesfellipe.github.io/post/2024-05-26-detec-o-de-linguagem-t-xica-com-o-llm-gemma-e-langchain/">Detec√ß√£o de Linguagem T√≥xica</a> - LLMs para an√°lise de texto</li>
<li><a href="https://gomesfellipe.github.io/post/2024-04-20-sentiment-analysis-llama2/">An√°lise de Sentimentos com LLM</a> - Processamento de linguagem natural</li>
</ul>
</div>
</div>
<div id="sobre-o-autor" class="section level1">
<h1>Sobre o autor</h1>
<p><em>Me chamo Fellipe Gomes, sou formado em estat√≠stica e atuo como cientista de dados desde 2018. Compartilho meus estudos e evolu√ß√£o por meio de artigos, tutoriais e projetos de c√≥digo aberto. Se quiser saber mais sobre meu trabalho, sinta-se √† vontade para entrar em contato atrav√©s das minhas redes sociais <a href="https://www.linkedin.com/in/gomesfellipe/">LinkedIn</a>, <a href="https://github.com/gomesfellipe">GitHub</a> e <a href="https://www.kaggle.com/gomes555">Kaggle</a>.</em></p>
<p><em>Gostou do conte√∫do? Compartilhe e deixe suas d√∫vidas nos coment√°rios. Sua experi√™ncia e feedback s√£o fundamentais para continuar criando conte√∫do de qualidade!</em></p>
</div>

        <p><strong>Leia o post completo em:</strong> <a href="https://gomesfellipe.github.io/post/2025-10-26-telemarketing-agent/">Agente para an√°lise interpretativa de liga√ß√µes de telemarketing</a></p>
        <p><em>Este post foi originalmente publicado em <a href="https://gomesfellipe.github.io/">Fellipe Gomes - Data Science Blog</a></em></p>
      ]]></content:encoded>
      <category>Intelig√™ncia Artificial</category>
      <category>Programa√ß√£o e Ferramentas</category>
      <category>Texto e NLP</category>
      <category domain="tag">call-center</category>
      <category domain="tag">gpt-4</category>
      <category domain="tag">langchain</category>
      <category domain="tag">nlp</category>
      <category domain="tag">python</category>
      <category domain="tag">sentiment-analysis</category>
      <category domain="tag">speech-to-text</category>
      <category domain="tag">telemarketing</category>
      <category domain="tag">voice-analytics</category>
      <category domain="tag">whisper</category>
    </item>
    <item>
      <title>Construindo uma Equipe Multiagente de IA para An√°lise do Mercado Bitcoin</title>
      <link>https://gomesfellipe.github.io/post/2025-05-04-bitcoin-agent/</link>
      <pubDate>Sun, 04 May 2025 00:00:00 +0000</pubDate>
      <author>gomes.fellipe1@gmail.com (Fellipe Carvalho Gomes)</author>
      <guid>https://gomesfellipe.github.io/post/2025-05-04-bitcoin-agent/</guid>
      <description>Neste post, exploramos a cria√ß√£o de uma equipe de agentes de IA usando Python, LangChain, LangGraph e LangSmith para automatizar e monitorar a an√°lise do mercado de Bitcoin, desde a coleta de dados at√© a gera√ß√£o de relat√≥rios automatizados.</description>
      <content:encoded>&lt;![CDATA[
        


<!-- Neste post, vamos mergulhar na cria√ß√£o de uma equipe de agentes de Intelig√™ncia Artificial (IA) que trabalham juntos para coletar dados, analisar tend√™ncias e decidir se √© hora de alertar sobre oportunidades de investimento no Bitcoin. Utilizaremos Python, o framework LangChain e sua extens√£o LangGraph para orquestrar esses agentes, al√©m de t√©cnicas de Prompt Engineering para garantir que cada "membro" da equipe execute sua fun√ß√£o com precis√£o.  -->
<!-- Voc√™ j√° se perguntou como acompanhar o vol√°til mercado de Bitcoin sem passar horas analisando gr√°ficos e indicadores complexos?  -->
<!-- Prepare-se para descobrir como a IA generativa pode se tornar sua aliada na an√°lise de criptomoedas! -->
<div id="por-que-analisar-o-mercado-bitcoin-com-agentes-de-ia" class="section level2">
<h2>Por que Analisar o Mercado Bitcoin com Agentes de IA?</h2>
<p>O cen√°rio do bitcoin sempre foi meio intrigante. Foi lan√ßado h√° 16 anos mas at√© hoje ningu√©m sabe ao certo quem est√° por tr√°s do projeto ‚Äî o criador, conhecido apenas pelo pseud√¥nimo Satoshi Nakamoto, <strong>nunca revelou sua identidade</strong>. Al√©m disso o bitcoin foi a <a href="https://www.mgcholding.com.br/blog/blockchain-bitcoin-e-ativos-virtuais-entenda-a-relacao/#:~:text=O%20blockchain%2C%20em%20sua%20ess%C3%AAncia,conhecida%20aplica%C3%A7%C3%A3o%20da%20tecnologia%20blockchain.">primeira e ainda √© a mais conhecida aplica√ß√£o da tecnologia <strong>Blockchain</strong></a>, que revolucionou a forma como lidamos com registros digitais e seguran√ßa dos dados. Sua <strong>natureza descentralizada</strong> e sua not√≥ria <strong>volatilidade</strong> o tornam um ativo √∫nico.</p>
<p>Quem n√£o se lembra da hist√≥ria das <a href="https://www.binance.com/pt-BR/square/post/17395016879858">pizzas compradas por 10.000 BTC</a>, que hoje valeriam uma fortuna? Mesmo que varia√ß√µes dessa magnitude sejam improv√°veis, eventos programados como o <a href="https://www.binance.com/pt-BR/events/bitcoin-halving"><strong>Halving</strong></a> ‚Äì que reduz pela metade a emiss√£o de novas moedas a cada quatro anos, simulando a escassez de metais preciosos ‚Äì continuam a impactar significativamente sua oferta e, historicamente, seu pre√ßo.</p>
<p>Mas como saber o momento certo de comprar ou vender? A resposta n√£o √© simples. O pre√ßo do Bitcoin √© influenciado por uma mir√≠ade de fatores: dados <strong>on-chain</strong> (movimenta√ß√µes na pr√≥pria blockchain), o cen√°rio <strong>macroecon√¥mico</strong> global (infla√ß√£o, taxas de juros), o <strong>sentimento do mercado</strong> e a <strong>an√°lise t√©cnica</strong> tradicional (padr√µes gr√°ficos e indicadores). Analisar isoladamente qualquer um desses aspectos oferece uma vis√£o incompleta. A verdadeira compreens√£o exige uma abordagem hol√≠stica, <strong>combinando diferentes perspectivas</strong>.</p>
<p>Foi pensando nisso, e inspirado pelos recentes avan√ßos em modelos de linguagem grandes (<strong>LLMs</strong>) e frameworks de <strong>agentes</strong>, que surgiu a ideia: <strong>E se eu delegar essa tarefa repetitiva e complexa a uma equipe de assistentes de IA?</strong> E se a IA pudesse n√£o apenas coletar e analisar os dados, mas tamb√©m <strong>interpretar o cen√°rio</strong> e <strong>sugerir a√ß√µes</strong> alinhadas a uma estrat√©gia de investimento de longo prazo, como a acumula√ß√£o gradual de Bitcoin?</p>
<p>√â aqui que entram os Agentes de IA. Pense neles como sistemas aut√¥nomos que utilizam um <strong>LLM</strong> (como os modelos GPT da OpenAI) como seu ‚Äúc√©rebro‚Äù ou motor de racioc√≠nio. Eles podem interagir com <strong>ferramentas</strong>, processar informa√ß√µes e <strong>tomar decis√µes</strong> para atingir um <strong>objetivo espec√≠fico</strong>. Em nosso caso, o objetivo ser√° fornecer uma an√°lise de mercado inteligente e automatizada, transformando dados brutos em insights acion√°veis de alto n√≠vel.</p>
</div>
<div id="arquitetura-da-solu√ß√£o-uma-equipe-de-agentes-de-ia-generativa" class="section level2">
<h2>Arquitetura da Solu√ß√£o: Uma Equipe de Agentes de IA Generativa</h2>
<p>Em vez de um √∫nico agente monol√≠tico tentando fazer tudo, o trabalho foi dividido em etapas l√≥gicas, cada uma atribu√≠da a um agente com um papel bem definido. Essa abordagem modular n√£o s√≥ organiza melhor o processo, mas tamb√©m facilita a manuten√ß√£o e a evolu√ß√£o de cada componente:</p>
<ul>
<li><strong>Data Fetcher</strong>: Coleta dados brutos de diversas APIs (cota√ß√µes, on-chain, macro, t√©cnicos).</li>
<li><strong>Data Analyst</strong>: Interpreta os dados brutos e gera um relat√≥rio t√©cnico formatado.</li>
<li><strong>Market Strategist</strong>: Sintetiza a an√°lise t√©cnica, identifica tend√™ncias e gera recomenda√ß√µes t√°ticas.</li>
<li><strong>Client Manager</strong>: Avalia a estrat√©gia sob a √≥tica do objetivo do ‚Äúcliente‚Äù (acumula√ß√£o de longo prazo) e decide se um alerta √© necess√°rio.</li>
</ul>
<p>Esses agentes utilizam <code>tools</code> (fun√ß√µes Python) para acessar APIs como <a href="https://www.blockchain.com/explorer/api">Blockchain.com</a>, <a href="https://pypi.org/project/yfinance/">Yahoo Finance</a>, <a href="https://www.coingecko.com/en/api/documentation">CoinGecko</a>, <a href="https://fred.stlouisfed.org/">FRED</a>, etc. A orquestra√ß√£o √© feita com o <strong><a href="https://github.com/features/actions">GitHub Actions</a></strong> que aciona a execu√ß√£o de todo o fluxo de trabalho todo dia - a cada 4 horas - executando o projeto que foi todo escrito em <strong>Python</strong>, <strong>LangChain</strong> (para os blocos de constru√ß√£o dos agentes), <strong>LangGraph</strong> (para o fluxo de trabalho), usando <strong>GPT-4o-mini</strong> como motor de racioc√≠nio, <strong><a href="https://telegram.me/BotFather">Telegram</a></strong> como um canal para envio de alertas e <strong>LangSmith</strong> para monitoramento e depura√ß√£o de cada passo da execu√ß√£o dos agentes.</p>
<p style="text-align: left; font-style: italic;">
üìå Clique <a href="https://gomesfellipe.github.io/post/2020-03-25-investment-alert/investment-alert/">aqui</a> para ler meu post sobre como criar bots no Telegram.
</p>
<center>
<div style="width: 90%;">
<p><img src="/post/2025-05-04-bitcoin-agent/full_workflow.png" alt="prompt chaining workflow" style="width: 100%;"></p>
</div>
<p style="text-align: center; font-style: italic;">
Fluxo de trabalho completo
</p>
</center>
</div>
<div id="construindo-o-workflow-com-langgraph" class="section level2">
<h2>Construindo o Workflow com LangGraph</h2>
<p>Para orquestrar a intera√ß√£o entre os agentes de forma robusta, foi utilizado o <strong>LangGraph</strong>, uma biblioteca sobre o LangChain para criar aplica√ß√µes LLM <em>stateful</em> e com <em>m√∫ltiplos atores</em>. Ele permite definir fluxos de trabalho como grafos, controlando explicitamente a sequ√™ncia e permitindo futuras ramifica√ß√µes ou ciclos.</p>
<div class="w3-panel w3-pale-blue w3-border">
<p>¬† üìå Os conceitos b√°sicos s√£o:</p>
<ul>
<li><strong>N√≥s (Nodes)</strong>: As unidades de trabalho (nossos agentes).</li>
<li><strong>Arestas (Edges)</strong>: As conex√µes que definem o fluxo de dados e controle entre os n√≥s.</li>
</ul>
</div>
<p>Montar o grafo envolve definir o estado compartilhado, adicionar os n√≥s e conectar as arestas. LangGraph oferece diferentes maneiras de definir essa estrutura. Abaixo, tem um exemplo conceitual usando tanto a a <strong>GraphAPI</strong>, que √© bastante expl√≠cita, quanto a <strong>Functional API</strong>, que √© mais direta ao ponto:</p>
<!-- Tabs HTML Structure -->
<div class="tabs">
<p><button class="tablink" onclick="openCode(event, 'GraphAPI')" id="defaultOpen">Graph API (Conceitual)</button>
<button class="tablink" onclick="openCode(event, 'FunctionalAPI')">Functional API (Conceitual)</button></p>
</div>
<div id="GraphAPI" class="tabcontent">
<pre class="python"><code>from langgraph.graph import StateGraph, START, END
from typing_extensions import TypedDict

# Definir o Estado do Grafo
class State(TypedDict):
    topic: str # Input do Data Fetcher
    raw_data: str # Sa√≠da do Data Fetcher
    analysis_report: str # Sa√≠da do Data Analyst
    strategy_synthesis: str # Sa√≠da do Market Strategist
    manager_decision: str # Sa√≠da do Client Manager

# Definir os N√≥s (Agentes/Fun√ß√µes)
# Supondo que as fun√ß√µes j√° foram definidas
def data_fetcher(state: State):
    # ... 
    return {&quot;raw_data&quot;: &quot;dados coletados...&quot;}

def data_analyst(state: State): ...
def market_strategist(state: State): ...
def client_manager(state: State): ...
def send_telegram_message(message_body): ...

# Construir o Grafo
workflow = StateGraph(State)

# Adicionar os n√≥s
workflow.add_node(&quot;fetcher&quot;, data_fetcher)
workflow.add_node(&quot;analyst&quot;, data_analyst)
workflow.add_node(&quot;strategist&quot;, market_strategist)
workflow.add_node(&quot;manager&quot;, client_manager)

# Definir Arestas (o fluxo sequencial)
workflow.add_edge(START, &quot;fetcher&quot;)
workflow.add_edge(&quot;fetcher&quot;, &quot;analyst&quot;)
workflow.add_edge(&quot;analyst&quot;, &quot;strategist&quot;)
workflow.add_conditional_edges(&quot;strategist&quot;, manager_decision, {
  &quot;ALERTAR_CLIENTE&quot;: &quot;send_telegram_message&quot;,
  &quot;NAO_ALERTAR&quot;: END
  })

# Compilar o grafo em um objeto execut√°vel
chain = workflow.compile()

# Executar (exemplo)
state = chain.invoke({&quot;topic&quot;: &quot;btc&quot;})</code></pre>
</div>
<div id="FunctionalAPI" class="tabcontent">
<pre class="python"><code>from langgraph.func import entrypoint, task

# Tasks/Agents

@task
def data_fetcher(topic: str) -&gt; dict: ...
  
@task 
def data_analyst(state: State): ...

@task
def market_strategist(state: State): ...

@task
def client_manager(state: State): ...

def plot_btc_analysis(): ...
def send_telegram_photo(fig): ...
def send_telegram_message(message_body): ...

# Exemplo conceitual com abordagem funcional (usando decoradores)
@entrypoint()
def chaining_workflow(topic: str):
    data_fetched = data_fetcher(topic).result()
    analyst_report = data_analyst(data_fetched).result()
    strategist_report = market_strategist(analyst_report).result()
    
    if &#39;ALERTAR&#39; in client_manager(strategist_report).result():
        fig = plot_btc_analysis()
        asyncio.run(send_telegram_photo(fig))
        asyncio.run(send_telegram_message(strategist_report))
        return &quot;Entrar em contato&quot;
    return &quot;N√£o entrar em contato&quot;

def run_chaining_workflow(topic: str, stream_mode: str = &quot;updates&quot;):
    return chaining_workflow.stream(topic, stream_mode=stream_mode)

# Invoke
logger.info(&quot;Iniciando o workflow...\n&quot;)
for step in run_chaining_workflow(&quot;&quot;, stream_mode=&quot;updates&quot;):
    for key, value in step.items():
        logger.info(f&quot;[ {key} ]\n{&#39;=&#39; * 80}\n{value}\n&quot;)
logger.info(&quot;Workflow finalizado.&quot;)
        </code></pre>
</div>
<!-- Script para funcionalidade das abas -->
<script>
function openCode(evt, codeName) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  tablinks = document.getElementsByClassName("tablink");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }
  document.getElementById(codeName).style.display = "block";
  evt.currentTarget.className += " active";
}
// Abre a primeira aba por padr√£o
document.getElementById("defaultOpen").click();
</script>
<!-- Estilos b√°sicos para as abas (adicione ao CSS do seu blog) -->
<style>
.tabs { overflow: hidden; border-bottom: 1px solid #ccc; margin-bottom: 10px; }
.tablink { background-color: #f1f1f1; float: left; border: none; outline: none; cursor: pointer; padding: 8px 16px; font-size: 1rem; transition: 0.3s; }
.tablink:hover { background-color: #ddd; }
.tablink.active { background-color: #ccc; }
.tabcontent { display: none; padding: 6px 0px; border-top: none; animation: fadeEffect 1s; }
@keyframes fadeEffect { from {opacity: 0;} to {opacity: 1;} }
</style>
<p>Este controle fino do fluxo, seja pela API expl√≠cita ou por abordagens mais funcionais, √© uma das grandes vantagens do LangGraph para sistemas multi-agentes, que ainda permite uma integra√ß√£o com o LangSmith para acompanhamento detalhado do fluxo de ‚Äúracioc√≠nio‚Äù dos agentes. Para mais detalhes, consulte a <a href="https://langchain-ai.github.io/langgraph/">documenta√ß√£o oficial</a>.</p>
</div>
<div id="mergulhando-nos-agentes-prompts-e-ferramentas" class="section level2">
<h2>Mergulhando nos Agentes: Prompts e Ferramentas</h2>
<p>Vamos ver rapidamente como cada agente funciona, focando nos prompts e ferramentas:</p>
<div id="agente-1-data-fetcher-o-pesquisador" class="section level3">
<h3>Agente 1: Data Fetcher (O Pesquisador)</h3>
<center>
<div style="width: 90%;">
<p><img src="/post/2025-05-04-bitcoin-agent/01.png" alt="data fetcher agent" style="width: 100%;"></p>
</div>
<p style="text-align: center; font-style: italic;">
Fluxo de trabalho do Data Researcher
</p>
</center>
<details>
<summary>
<em>Ver c√≥digo</em>
</summary>
<pre class="python"><code>from pydantic import BaseModel, Field
from langchain.schema.messages import HumanMessage, ToolMessage
from langgraph.func import task
from langchain_openai import ChatOpenAI

from tools.fetch_data_btc import fetch_data_btc
from tools.fetch_data_onchain import fetch_data_onchain
from tools.fetch_data_macroeconomic import fetch_data_macroeconomic
from tools.fetch_data_market import fetch_data_market
from tools.fetch_data_tecnical import fetch_data_tecnical

llm = ChatOpenAI(model=&quot;gpt-4o-mini&quot;, temperature=0)

@task
def data_fetcher(topic: str):
  
  class StructuredJsonOutput(BaseModel):
    btc_data: str = Field(None, description=&quot;Bitcoin data and USD to BRL exchange rate&quot;)
    onchain_data: str = Field(None, description=&quot;On-chain Bitcoin data&quot;)
    macroeconomic_data: str = Field(None, description=&quot;Macroeconomic data&quot;)
    market_data: str = Field(None, description=&quot;Market sentiment and Bitcoin-related metrics&quot;)
    tecnical_data: str = Field(None, description=&quot;technical analysis indicators for Bitcoin&quot;)

  structured_llm = llm.with_structured_output(StructuredJsonOutput)

  instructions = &quot;Voc√™ √© um pesquisador respons√°vel por coletar dados de diferentes fontes sobre o mercado de Bitcoin e gerar um output no formato json.&quot;

  tools = [
      fetch_data_btc,
      fetch_data_onchain,
      fetch_data_macroeconomic,
      fetch_data_market,
      fetch_data_tecnical
      ]

  tools_by_name = {tool.name: tool for tool in tools}

  llm_with_tools = llm.bind_tools(tools)

  messages = [HumanMessage(instructions)]
  ai_msg = llm_with_tools.invoke(messages)
  messages.append(ai_msg)

  for tool_call in ai_msg.tool_calls:
      selected_tool = tools_by_name[tool_call[&quot;name&quot;].lower()]
      tool_output = selected_tool.invoke(tool_call[&quot;args&quot;])
      messages.append(ToolMessage(tool_output, tool_call_id=tool_call[&quot;id&quot;]))

  messages.append(structured_llm.invoke(messages))

  return messages[-1].model_dump_json(indent=3)</code></pre>
</details>
<ul>
<li><strong>Objetivo</strong>: Coletar dados brutos e atualizados de diversas fontes sobre o Bitcoin, abrangendo cota√ß√µes, indicadores on-chain, dados macroecon√¥micos e t√©cnicos.</li>
<li><strong>Funcionamento</strong>: Este agente n√£o calcula nem interpreta, ele apenas orquestra a chamada de v√°rias <code>tools</code> (fun√ß√µes Python que interagem com APIs externas). Essa fun√ß√£o do LangChain permite que o LLM, ao receber a instru√ß√£o inicial (‚Äúcolete os dados sobre o mercado de Bitcoin‚Äù), analise as ferramentas dispon√≠veis e decida quais delas chamar e com quais argumentos. Ap√≥s as ferramentas retornarem seus resultados, usamos <code>llm.with_structured_output(StructuredJsonOutput)</code> para instruir o LLM a consolidar todas as informa√ß√µes coletadas em um √∫nico objeto <strong>JSON estruturado</strong>. Isso garante que a sa√≠da do Data Fetcher seja consistente e f√°cil de processar pelo pr√≥ximo agente.</li>
</ul>
</div>
<div id="agente-2-data-analyst-o-int√©rprete" class="section level3">
<h3>Agente 2: Data Analyst (O Int√©rprete)</h3>
<center>
<div style="width: 90%;">
<p><img src="/post/2025-05-04-bitcoin-agent/02.png" alt="data analyst agent" style="width: 100%;"></p>
</div>
<p style="text-align: center; font-style: italic;">
Fluxo de trabalho do Data Analyst
</p>
</center>
<details>
<summary>
<em>Ver c√≥digo</em>
</summary>
<pre class="python"><code>from langgraph.func import task
from langchain.prompts import ChatPromptTemplate, FewShotChatMessagePromptTemplate
from langchain_openai import ChatOpenAI

from prompts.data_analyst_example import input_example, output_example

llm = ChatOpenAI(model=&quot;gpt-4&quot;, temperature=0.7)

@task
def data_analyst(report: str):

  input = f&quot;&quot;&quot;
  Voc√™ √© um analista financeiro experiente em Cryptomoedas e especialista em Bitcoin.
  Analise as tend√™ncias do cen√°rio do Bitcoin hoje com base no json \
  delimitado por tr√™s crases (```):

  \```
  {report}
  \```

  Siga rigorosamente as instru√ß√µes abaixo:

  - ...
  &quot;&quot;&quot;

  examples = [
      {&quot;input&quot;: input_example, &quot;output&quot;: output_example},
       ]

  example_prompt = ChatPromptTemplate.from_messages([
      (&quot;human&quot;, &quot;{input}&quot;),
      (&quot;ai&quot;, &quot;{output}&quot;),
      ])

  few_shot_prompt = FewShotChatMessagePromptTemplate(
      example_prompt=example_prompt,
      examples=examples,
      )

  prompt_system = &quot;Voc√™ √© um analista financeiro experiente em Criptomoedas e especialista em Bitcoin.&quot;

  final_prompt = ChatPromptTemplate.from_messages([
    (&quot;system&quot;, prompt_system),
    few_shot_prompt,
    (&quot;human&quot;, &quot;{input}&quot;),
    ])

  chain = final_prompt | llm

  msg = chain.invoke(input=input)

  return msg.content</code></pre>
</details>
<ul>
<li><strong>Objetivo</strong>: Receber o JSON de dados brutos do Data Fetcher e transform√°-lo em um relat√≥rio anal√≠tico coeso, formatado em Markdown, interpretando cada indicador e explicando seu poss√≠vel impacto.</li>
<li><strong>Prompt Engineering em A√ß√£o</strong>: Este agente √© um √≥timo exemplo de como guiar um LLM para tarefas complexas de formata√ß√£o e interpreta√ß√£o.
<ul>
<li><strong>Instru√ß√µes Detalhadas</strong>: O prompt define explicitamente o papel do agente (‚Äúanalista financeiro experiente‚Äù), o formato desejado (Markdown, bullet points, negrito), o tom (‚Äúequilibrado e menos t√©cnico‚Äù), e regras espec√≠ficas (mencionar pre√ßos em USD e BRL, usar sinal de menos para varia√ß√µes negativas, seguir a estrutura do exemplo).</li>
<li><strong>Estrat√©gia Few-Shot</strong>: Para garantir que o LLM siga o formato e o estilo de interpreta√ß√£o desejados, utilizamos a t√©cnica Few-Shot (semelhante como fiz em um <a href="https://gomesfellipe.github.io/post/2024-05-26-detec-o-de-linguagem-t-xica-com-o-llm-gemma-e-langchain/">post anterior</a>). Fornecemos um exemplo completo de um input (um JSON de dados similar ao que o Data Fetcher produziria) e o output correspondente (o relat√≥rio em Markdown formatado e interpretado). Isso √© feito usando <code>FewShotChatMessagePromptTemplate</code> do LangChain, que insere o exemplo diretamente no contexto do prompt final.</li>
<li><strong>Cadeia LCEL</strong>: O prompt final √© constru√≠do usando a LangChain Expression Language (LCEL), combinando o prompt do sistema (definindo o papel), o prompt Few-Shot (com o exemplo) e o prompt humano (contendo as instru√ß√µes e o JSON de dados brutos atual).</li>
</ul></li>
</ul>
</div>
<div id="agente-3-market-strategist-o-conselheiro" class="section level3">
<h3>Agente 3: Market Strategist (O Conselheiro)</h3>
<center>
<div style="width: 80%;">
<p><img src="/post/2025-05-04-bitcoin-agent/03.png" alt="market strategist agent" style="width: 100%;"></p>
</div>
<p style="text-align: center; font-style: italic;">
Fluxo de trabalho do Market Strategist
</p>
</center>
<details>
<summary>
<em>Ver c√≥digo</em>
</summary>
<pre class="python"><code>from langgraph.func import task
from langchain.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(temperature=0.7)

@task
def market_strategist(analyst_report: str):
    &quot;&quot;&quot;
    Gera recomenda√ß√µes de posicionamento com base na an√°lise do Data Analyst.
    &quot;&quot;&quot;
  
    input = f&quot;&quot;&quot;
    Seu papel √© analisar o relat√≥rio t√©cnico fornecido no formatado em Markdown e transformar\
    em uma s√≠ntese estrat√©gica e executiva, com alertas, insights e orienta√ß√µes t√°ticas de alto n√≠vel.
  
    \``` markdown
    {analyst_report}
    \```
  
    Siga rigorosamente as instru√ß√µes abaixo:
  
    - ...
    &quot;&quot;&quot;
  
    prompt = ChatPromptTemplate.from_messages([
        (&quot;system&quot;, &quot;Voc√™ √© um estrategista de mercado s√™nior, com ampla experi√™ncia em ativos digitais e especializa√ß√£o em Bitcoin.&quot;),
        (&quot;human&quot;, &quot;{input}&quot;)
    ])
  
    chain = prompt | llm
    msg = chain.invoke(input=input)
    return msg.content
</code></pre>
</details>
<ul>
<li><strong>Objetivo</strong>: Ler o relat√≥rio t√©cnico detalhado do Data Analyst e interpretar as informa√ß√µes em uma s√≠ntese estrat√©gica e executiva. O foco √© identificar a tend√™ncia geral, destacar sinais chave e fornecer recomenda√ß√µes t√°ticas claras.</li>
<li><strong>Prompt</strong>: O prompt para este agente √© crucial para mudar o n√≠vel da an√°lise. Ele instrui o LLM a agir como um ‚Äúestrategista de mercado s√™nior‚Äù, focando em:
<ul>
<li><strong>Resumo</strong>: Extrair os pontos mais cr√≠ticos.</li>
<li><strong>Tend√™ncia</strong>: Classificar o mercado (alta, baixa, neutro).</li>
<li><strong>Sinais</strong>: Identificar indicadores de otimismo ou cautela.</li>
<li><strong>Recomenda√ß√µes</strong>: Gerar orienta√ß√µes pr√°ticas e acion√°veis (‚Äúisso indica que‚Ä¶‚Äù, ‚Äúlogo, √© prudente‚Ä¶‚Äù).</li>
<li><strong>Racioc√≠nio</strong>: Explicitar o processo de pensamento com <strong>CoT</strong> (<strong>Chain-of-Thought</strong>) que levou √†s conclus√µes antes de apresentar a s√≠ntese final.</li>
<li><strong>Tom</strong>: Consultivo, direto e profissional.</li>
</ul></li>
</ul>
</div>
<div id="agente-4-client-manager-o-porteiro" class="section level3">
<h3>Agente 4: Client Manager (O Porteiro)</h3>
<center>
<div style="width: 80%;">
<p><img src="/post/2025-05-04-bitcoin-agent/04.png" alt="client manager agent" style="width: 100%;"></p>
</div>
<p style="text-align: center; font-style: italic;">
Fluxo de trabalho do Client Manager
</p>
</center>
<details>
<summary>
<em>Ver c√≥digo</em>
</summary>
<pre class="python"><code>from langgraph.func import task
from langchain.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(temperature=0.7)

@task
def client_manager(final_report: str):
    &quot;&quot;&quot;
    Avalia o relat√≥rio estrat√©gico e decide se deve ou n√£o alertar o cliente.
    A decis√£o final √© bin√°ria: ALERTAR_CLIENTE ou N√ÉO_ALERTAR.
    &quot;&quot;&quot;

    input = f&quot;&quot;&quot;
    Objetivo do cliente: Acumular Bitcoins no longo prazo, investindo mensalmente nas melhores janelas de oportunidade.

    Seu papel √© avaliar o relat√≥rio abaixo e decidir se h√° motivos suficientes para alertar o cliente:

    \``` markdown
    {final_report}
    \```

    Siga rigorosamente as instru√ß√µes abaixo:

    - ...
    &quot;&quot;&quot;

    prompt = ChatPromptTemplate.from_messages([
        (&quot;system&quot;, &quot;Voc√™ √© um Client Manager, especializado em comunica√ß√£o estrat√©gica com clientes de alto valor.&quot;),
        (&quot;human&quot;, &quot;{input}&quot;)
    ])

    chain = prompt | llm
    msg = chain.invoke(input=input)
    return msg.content
</code></pre>
</details>
<ul>
<li><strong>Objetivo</strong>: Avaliar a s√≠ntese estrat√©gica do Market Strategist √† luz do objetivo espec√≠fico do cliente (acumula√ß√£o de longo prazo) e tomar uma decis√£o bin√°ria: a situa√ß√£o atual justifica um alerta ou n√£o?</li>
<li><strong>Prompt</strong>: Este prompt √© focado na tomada de decis√£o.
<ul>
<li><strong>Contexto do Cliente</strong>: Define claramente o objetivo (‚ÄúAcumular Bitcoins no longo prazo, investindo mensalmente nas melhores janelas de oportunidade.‚Äù).</li>
<li><strong>Crit√©rios de Alerta</strong>: Especifica o que procurar (mudan√ßa relevante de tend√™ncia, risco/oportunidade claros, indicadores extremos, recomenda√ß√µes urgentes).</li>
<li><strong>Racioc√≠nio Obrigat√≥rio</strong>: Exige que o agente explique seu processo de pensamento <strong>CoT</strong> (<strong>Chain-of-Thought</strong>) antes da decis√£o final.</li>
<li><strong>Output Bin√°rio</strong>: A resposta final deve ser <em>apenas</em> a palavra <code>ALERTAR</code> ou <code>N√ÉO_ALERTAR</code> em mai√∫sculas, precedida pelo racioc√≠nio.</li>
</ul></li>
</ul>
</div>
</div>
<div id="desafios-aprendizados-e-observabilidade" class="section level2">
<h2>Desafios, Aprendizados e Observabilidade</h2>
<p>Construir agentes envolve desafios:</p>
<ul>
<li><strong>Prompt Engineering</strong>: √â uma arte iterativa. Clareza, exemplos (Few-Shot) e estrutura s√£o essenciais.</li>
<li><strong>Orquestra√ß√£o (LangGraph)</strong>: Gerenciar o estado e o fluxo entre n√≥s exige aten√ß√£o.</li>
<li><strong>Integra√ß√£o de Ferramentas</strong>: Descri√ß√µes claras das <code>tools</code> s√£o vitais para o LLM us√°-las corretamente.</li>
<li><strong>Observabilidade</strong>: Identificar falhas em fluxos complexos pode ser dif√≠cil.</li>
</ul>
<p>Ferramentas como o <strong>LangSmith</strong> s√£o extremamente √∫teis na monitoramento dos agentes, permitindo rastrear e depurar cada passo de sua execu√ß√£o, chamadas de LLM e uso de ferramentas. Ele oferece uma vis√£o clara do que est√° acontecendo ‚Äúpor baixo dos panos‚Äù, facilitando a identifica√ß√£o de gargalos ou erros.</p>
<center>
<div style="width: 90%;">
<p><img src="/post/2025-05-04-bitcoin-agent/langsmith-exemplo.png" alt="langsmith" style="width: 100%;"></p>
</div>
<p style="text-align: center; font-style: italic;">
Print da tela do LangSmith do projeto
</p>
</center>
</div>
<div id="conclus√£o" class="section level2">
<h2>Conclus√£o</h2>
<p>Criamos uma equipe de agentes IA capaz de automatizar a complexa an√°lise do mercado Bitcoin, usando LangChain e LangGraph para orquestra√ß√£o. O sistema coleta dados, interpreta, gera estrat√©gias e decide sobre alertas, transformando dados brutos em insights acion√°veis. Veja como √© o alerta recebido no Telegram:</p>
<div style="display: flex; justify-content: space-between; align-items: center;">
<center>
<p><img src="/post/2025-05-04-bitcoin-agent/telegram1.PNG" alt="Report no Telegram 1" style="width: 80%;"></p>
</center>
<center>
<p><img src="/post/2025-05-04-bitcoin-agent/telegram2.PNG" alt="Report no Telegram 2" style="width: 80%;"></p>
</center>
</div>
<p style="text-align: center; font-style: italic;">
Print das telas do bot no Telegram.
</p>
<p>Este projeto demonstra o potencial dos agentes para automatizar tarefas repetitivas que envolvem a tomada de decis√µes com um certo ‚Äúracioc√≠nio‚Äù. Os pr√≥ximos passos podem envolver refinar prompts, adicionar mais ferramentas, integrar mais visualiza√ß√µes ou implementar notifica√ß√µes ativas.</p>
</div>
<div id="refer√™ncias" class="section level2">
<h2>Refer√™ncias</h2>
<ul>
<li><a href="https://python.langchain.com/">LangChain - Documenta√ß√£o</a></li>
<li><a href="https://langchain-ai.github.io/langgraph/">LangGraph - Documenta√ß√£o</a></li>
<li><a href="https://smith.langchain.com/">LangSmith - Documenta√ß√£o</a></li>
<li><a href="https://openai.com/api/">OpenAI API Plataform</a></li>
<li><a href="https://github.com/openai/openai-cookbook/blob/main/examples/gpt4-1_prompting_guide.ipynb">OpenAI - Prompt Engineering Guide</a></li>
<li><a href="https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf">OpenAI - A Practical Guide to Building Agents</a></li>
<li><a href="https://langchain-ai.github.io/langgraph/tutorials/workflows/">LangGraph Tutorial - Building Agentic Workflows</a></li>
<li><a href="https://blog.langchain.dev/how-to-think-about-agent-frameworks/">LangChain Blog - How to think about agent frameworks</a></li>
</ul>
</div>

        <p><strong>Leia o post completo em:</strong> <a href="https://gomesfellipe.github.io/post/2025-05-04-bitcoin-agent/">Construindo uma Equipe Multiagente de IA para An√°lise do Mercado Bitcoin</a></p>
        <p><em>Este post foi originalmente publicado em <a href="https://gomesfellipe.github.io/">Fellipe Gomes - Data Science Blog</a></em></p>
      ]]></content:encoded>
      <category>Fundamentos de Data Science</category>
      <category>Intelig√™ncia Artificial</category>
      <category>Programa√ß√£o e Ferramentas</category>
      <category domain="tag">agent-ai</category>
      <category domain="tag">analise-dados</category>
      <category domain="tag">bitcoin</category>
      <category domain="tag">crypto</category>
      <category domain="tag">inteligencia-artificial</category>
      <category domain="tag">langchain</category>
      <category domain="tag">langgraph</category>
      <category domain="tag">langsmith</category>
      <category domain="tag">llm</category>
      <category domain="tag">mercado-financeiro</category>
    </item>
  </channel>
</rss>