---
title: Construindo uma Equipe Multiagente de IA para An√°lise do Mercado Bitcoin
author: Fellipe Gomes
date: '2025-05-04'
slug: []
categories:
  - Python
  - Pr√°tica
  - LLM
  - IA
  - Agentes
  - LangChain
  - LangGraph
  - LangSmith
  - Bitcoin
  - An√°lise de Dados
  - Mercado Financeiro
  - OpenAI
tags:
  - LLM
  - LangChain
  - LangGraph
  - LangSmith
  - Python
  - AI
  - Bitcoin
  - Crypto
  - AgentAI
  - AnaliseDeDados
  - MercadoFinanceiro
  - gomesfellipe
  - OpenAI
description: 'Neste post, exploramos a cria√ß√£o de uma equipe de agentes de IA usando Python, LangChain, LangGraph e LangSmith para automatizar e monitorar a an√°lise do mercado de Bitcoin, desde a coleta de dados at√© a gera√ß√£o de relat√≥rios automatizados.'
featured: 'img3.jpg'
featuredalt: 'Equipe de agentes IA analisando dados do Bitcoin em interface hologr√°fica'
featuredpath: 'date'
linktitle: ''
type: "post"
output: 
  blogdown::html_page:
    toc: true
    toc_depth: 1 
image_preview: 'img2.jpg' 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

<!-- Neste post, vamos mergulhar na cria√ß√£o de uma equipe de agentes de Intelig√™ncia Artificial (IA) que trabalham juntos para coletar dados, analisar tend√™ncias e decidir se √© hora de alertar sobre oportunidades de investimento no Bitcoin. Utilizaremos Python, o framework LangChain e sua extens√£o LangGraph para orquestrar esses agentes, al√©m de t√©cnicas de Prompt Engineering para garantir que cada "membro" da equipe execute sua fun√ß√£o com precis√£o.  -->

<!-- Voc√™ j√° se perguntou como acompanhar o vol√°til mercado de Bitcoin sem passar horas analisando gr√°ficos e indicadores complexos?  -->

<!-- Prepare-se para descobrir como a IA generativa pode se tornar sua aliada na an√°lise de criptomoedas! -->

## Por que Analisar o Mercado Bitcoin com Agentes de IA?

O cen√°rio do bitcoin sempre foi meio intrigante. Foi lan√ßado h√° 16 anos mas at√© hoje ningu√©m sabe ao certo quem est√° por tr√°s do projeto ‚Äî o criador, conhecido apenas pelo pseud√¥nimo Satoshi Nakamoto, **nunca revelou sua identidade**. Al√©m disso o bitcoin foi a [primeira e ainda √© a mais conhecida aplica√ß√£o da tecnologia **Blockchain**](https://www.mgcholding.com.br/blog/blockchain-bitcoin-e-ativos-virtuais-entenda-a-relacao/#:~:text=O%20blockchain%2C%20em%20sua%20ess%C3%AAncia,conhecida%20aplica%C3%A7%C3%A3o%20da%20tecnologia%20blockchain.), que revolucionou a forma como lidamos com registros digitais e seguran√ßa dos dados. Sua **natureza descentralizada** e sua not√≥ria **volatilidade** o tornam um ativo √∫nico. 

Quem n√£o se lembra da hist√≥ria das [pizzas compradas por 10.000 BTC](https://www.binance.com/pt-BR/square/post/17395016879858), que hoje valeriam uma fortuna? Mesmo que varia√ß√µes dessa magnitude sejam improv√°veis, eventos programados como o [**Halving**](https://www.binance.com/pt-BR/events/bitcoin-halving) ‚Äì que reduz pela metade a emiss√£o de novas moedas a cada quatro anos, simulando a escassez de metais preciosos ‚Äì continuam a impactar significativamente sua oferta e, historicamente, seu pre√ßo.

Mas como saber o momento certo de comprar ou vender? A resposta n√£o √© simples. O pre√ßo do Bitcoin √© influenciado por uma mir√≠ade de fatores: dados **on-chain** (movimenta√ß√µes na pr√≥pria blockchain), o cen√°rio **macroecon√¥mico** global (infla√ß√£o, taxas de juros), o **sentimento do mercado** e a **an√°lise t√©cnica** tradicional (padr√µes gr√°ficos e indicadores). Analisar isoladamente qualquer um desses aspectos oferece uma vis√£o incompleta. A verdadeira compreens√£o exige uma abordagem hol√≠stica, **combinando diferentes perspectivas**.

Foi pensando nisso, e inspirado pelos recentes avan√ßos em modelos de linguagem grandes (**LLMs**) e frameworks de **agentes**, que surgiu a ideia: **E se eu delegar essa tarefa repetitiva e complexa a uma equipe de assistentes de IA?** E se a IA pudesse n√£o apenas coletar e analisar os dados, mas tamb√©m **interpretar o cen√°rio** e **sugerir a√ß√µes** alinhadas a uma estrat√©gia de investimento de longo prazo, como a acumula√ß√£o gradual de Bitcoin?

√â aqui que entram os Agentes de IA. Pense neles como sistemas aut√¥nomos que utilizam um **LLM** (como os modelos GPT da OpenAI) como seu "c√©rebro" ou motor de racioc√≠nio. Eles podem interagir com **ferramentas**, processar informa√ß√µes e **tomar decis√µes** para atingir um **objetivo espec√≠fico**. Em nosso caso, o objetivo ser√° fornecer uma an√°lise de mercado inteligente e automatizada, transformando dados brutos em insights acion√°veis de alto n√≠vel.

## Arquitetura da Solu√ß√£o: Uma Equipe de Agentes de IA Generativa

Em vez de um √∫nico agente monol√≠tico tentando fazer tudo, o trabalho foi dividido em etapas l√≥gicas, cada uma atribu√≠da a um agente com um papel bem definido. Essa abordagem modular n√£o s√≥ organiza melhor o processo, mas tamb√©m facilita a manuten√ß√£o e a evolu√ß√£o de cada componente:

*   **Data Fetcher**: Coleta dados brutos de diversas APIs (cota√ß√µes, on-chain, macro, t√©cnicos).
*   **Data Analyst**: Interpreta os dados brutos e gera um relat√≥rio t√©cnico formatado.
*   **Market Strategist**: Sintetiza a an√°lise t√©cnica, identifica tend√™ncias e gera recomenda√ß√µes t√°ticas.
*   **Client Manager**: Avalia a estrat√©gia sob a √≥tica do objetivo do "cliente" (acumula√ß√£o de longo prazo) e decide se um alerta √© necess√°rio.

Esses agentes utilizam `tools` (fun√ß√µes Python) para acessar APIs como [Blockchain.com](https://www.blockchain.com/explorer/api), [Yahoo Finance](https://pypi.org/project/yfinance/), [CoinGecko](https://www.coingecko.com/en/api/documentation), [FRED](https://fred.stlouisfed.org/), etc. A  orquestra√ß√£o √© feita com o **[GitHub Actions](https://github.com/features/actions)** que aciona a execu√ß√£o de todo o fluxo de trabalho todo dia - a cada 4 horas - executando o projeto que foi todo escrito em **Python**, **LangChain** (para os blocos de constru√ß√£o dos agentes), **LangGraph** (para o fluxo de trabalho), usando **GPT-4o-mini** como motor de racioc√≠nio, **[Telegram](https://telegram.me/BotFather)** como um canal para envio de alertas e **LangSmith** para monitoramento e depura√ß√£o de cada passo da execu√ß√£o dos agentes. 

<p style="text-align: left; font-style: italic;">üìå Clique [aqui](https://gomesfellipe.github.io/post/2020-03-25-investment-alert/investment-alert/) para ler meu post sobre como criar bots no Telegram.</p>

<center>

<div style="width: 90%;">
<img src="/post/2025-05-04-bitcoin-agent/full_workflow.png" alt="prompt chaining workflow" style="width: 100%;">
</div> 
<p style="text-align: center; font-style: italic;">Fluxo de trabalho completo</p>

</center>

## Construindo o Workflow com LangGraph

Para orquestrar a intera√ß√£o entre os agentes de forma robusta, foi utilizado o **LangGraph**, uma biblioteca sobre o LangChain para criar aplica√ß√µes LLM *stateful* e com *m√∫ltiplos atores*. Ele permite definir fluxos de trabalho como grafos, controlando explicitamente a sequ√™ncia e permitindo futuras ramifica√ß√µes ou ciclos.

<div class="w3-panel w3-pale-blue w3-border">
&nbsp; üìå Os conceitos b√°sicos s√£o:

*   **N√≥s (Nodes)**: As unidades de trabalho (nossos agentes).
*   **Arestas (Edges)**: As conex√µes que definem o fluxo de dados e controle entre os n√≥s.

</div>



Montar o grafo envolve definir o estado compartilhado, adicionar os n√≥s e conectar as arestas. LangGraph oferece diferentes maneiras de definir essa estrutura. Abaixo, tem um exemplo conceitual usando tanto a a **GraphAPI**, que √© bastante expl√≠cita, quanto a **Functional API**, que √© mais direta ao ponto:

<!-- Tabs HTML Structure -->
<div class="tabs">
  <button class="tablink" onclick="openCode(event, 'GraphAPI')" id="defaultOpen">Graph API (Conceitual)</button>
  <button class="tablink" onclick="openCode(event, 'FunctionalAPI')">Functional API (Conceitual)</button>
</div>

<div id="GraphAPI" class="tabcontent">

```{python}
from langgraph.graph import StateGraph, START, END
from typing_extensions import TypedDict

# Definir o Estado do Grafo
class State(TypedDict):
    topic: str # Input do Data Fetcher
    raw_data: str # Sa√≠da do Data Fetcher
    analysis_report: str # Sa√≠da do Data Analyst
    strategy_synthesis: str # Sa√≠da do Market Strategist
    manager_decision: str # Sa√≠da do Client Manager

# Definir os N√≥s (Agentes/Fun√ß√µes)
# Supondo que as fun√ß√µes j√° foram definidas
def data_fetcher(state: State):
    # ... 
    return {"raw_data": "dados coletados..."}

def data_analyst(state: State): ...
def market_strategist(state: State): ...
def client_manager(state: State): ...
def send_telegram_message(message_body): ...

# Construir o Grafo
workflow = StateGraph(State)

# Adicionar os n√≥s
workflow.add_node("fetcher", data_fetcher)
workflow.add_node("analyst", data_analyst)
workflow.add_node("strategist", market_strategist)
workflow.add_node("manager", client_manager)

# Definir Arestas (o fluxo sequencial)
workflow.add_edge(START, "fetcher")
workflow.add_edge("fetcher", "analyst")
workflow.add_edge("analyst", "strategist")
workflow.add_conditional_edges("strategist", manager_decision, {
  "ALERTAR_CLIENTE": "send_telegram_message",
  "NAO_ALERTAR": END
  })

# Compilar o grafo em um objeto execut√°vel
chain = workflow.compile()

# Executar (exemplo)
state = chain.invoke({"topic": "btc"})
```

</div>

<div id="FunctionalAPI" class="tabcontent">

```{python}
from langgraph.func import entrypoint, task

# Tasks/Agents

@task
def data_fetcher(topic: str) -> dict: ...
  
@task 
def data_analyst(state: State): ...

@task
def market_strategist(state: State): ...

@task
def client_manager(state: State): ...

def plot_btc_analysis(message_body): ...
def send_telegram_photo(message_body): ...
def send_telegram_message(message_body): ...

# Exemplo conceitual com abordagem funcional (usando decoradores)
@entrypoint()
def chaining_workflow(topic: str):
    data_fetched = data_fetcher(topic).result()
    analyst_report = data_analyst(data_fetched).result()
    strategist_report = market_strategist(analyst_report).result()
    
    if 'ALERTAR' in client_manager(strategist_report).result():
        fig = plot_btc_analysis()
        asyncio.run(send_telegram_photo(fig))
        asyncio.run(send_telegram_message(strategist_report))
        return "Entrar em contato"
    return "N√£o entrar em contato"

def run_chaining_workflow(topic: str, stream_mode: str = "updates"):
    return chaining_workflow.stream(topic, stream_mode=stream_mode)

# Invoke
logger.info("Iniciando o workflow...\n")
for step in run_chaining_workflow("", stream_mode="updates"):
    for key, value in step.items():
        logger.info(f"[ {key} ]\n{'=' * 80}\n{value}\n")
logger.info("Workflow finalizado.")
        
```

</div>

<!-- Script para funcionalidade das abas -->
<script>
function openCode(evt, codeName) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  tablinks = document.getElementsByClassName("tablink");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }
  document.getElementById(codeName).style.display = "block";
  evt.currentTarget.className += " active";
}
// Abre a primeira aba por padr√£o
document.getElementById("defaultOpen").click();
</script>

<!-- Estilos b√°sicos para as abas (adicione ao CSS do seu blog) -->
<style>
.tabs { overflow: hidden; border-bottom: 1px solid #ccc; margin-bottom: 10px; }
.tablink { background-color: #f1f1f1; float: left; border: none; outline: none; cursor: pointer; padding: 8px 16px; font-size: 1rem; transition: 0.3s; }
.tablink:hover { background-color: #ddd; }
.tablink.active { background-color: #ccc; }
.tabcontent { display: none; padding: 6px 0px; border-top: none; animation: fadeEffect 1s; }
@keyframes fadeEffect { from {opacity: 0;} to {opacity: 1;} }
</style>

Este controle fino do fluxo, seja pela API expl√≠cita ou por abordagens mais funcionais, √© uma das grandes vantagens do LangGraph para sistemas multi-agentes, que ainda permite uma integra√ß√£o com o LangSmith para acompanhamento detalhado do fluxo de "racioc√≠nio" dos agentes. Para mais detalhes, consulte a [documenta√ß√£o oficial](https://langchain-ai.github.io/langgraph/).

## Mergulhando nos Agentes: Prompts e Ferramentas

Vamos ver rapidamente como cada agente funciona, focando nos prompts e ferramentas:

### Agente 1: Data Fetcher (O Pesquisador)

<center>

<div style="width: 90%;">
<img src="/post/2025-05-04-bitcoin-agent/01.png" alt="data fetcher agent" style="width: 100%;">
</div> 
<p style="text-align: center; font-style: italic;">Fluxo de trabalho do Data Researcher</p>

</center>

<details>
<summary>*Ver c√≥digo*</summary>
```{python}
from pydantic import BaseModel, Field
from langchain.schema.messages import HumanMessage, ToolMessage
from langgraph.func import task
from langchain_openai import ChatOpenAI

from tools.fetch_data_btc import fetch_data_btc
from tools.fetch_data_onchain import fetch_data_onchain
from tools.fetch_data_macroeconomic import fetch_data_macroeconomic
from tools.fetch_data_market import fetch_data_market
from tools.fetch_data_tecnical import fetch_data_tecnical

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

@task
def data_fetcher(topic: str):
  
  class StructuredJsonOutput(BaseModel):
    btc_data: str = Field(None, description="Bitcoin data and USD to BRL exchange rate")
    onchain_data: str = Field(None, description="On-chain Bitcoin data")
    macroeconomic_data: str = Field(None, description="Macroeconomic data")
    market_data: str = Field(None, description="Market sentiment and Bitcoin-related metrics")
    tecnical_data: str = Field(None, description="technical analysis indicators for Bitcoin")

  structured_llm = llm.with_structured_output(StructuredJsonOutput)

  instructions = "Voc√™ √© um pesquisador respons√°vel por coletar dados de diferentes fontes sobre o mercado de Bitcoin e gerar um output no formato json."

  tools = [
      fetch_data_btc,
      fetch_data_onchain,
      fetch_data_macroeconomic,
      fetch_data_market,
      fetch_data_tecnical
      ]

  tools_by_name = {tool.name: tool for tool in tools}

  llm_with_tools = llm.bind_tools(tools)

  messages = [HumanMessage(instructions)]
  ai_msg = llm_with_tools.invoke(messages)
  messages.append(ai_msg)

  for tool_call in ai_msg.tool_calls:
      selected_tool = tools_by_name[tool_call["name"].lower()]
      tool_output = selected_tool.invoke(tool_call["args"])
      messages.append(ToolMessage(tool_output, tool_call_id=tool_call["id"]))

  messages.append(structured_llm.invoke(messages))

  return messages[-1].model_dump_json(indent=3)
```

</details>

*   **Objetivo**: Coletar dados brutos e atualizados de diversas fontes sobre o Bitcoin, abrangendo cota√ß√µes, indicadores on-chain, dados macroecon√¥micos e t√©cnicos.
*   **Funcionamento**: Este agente n√£o calcula nem interpreta, ele apenas orquestra a chamada de v√°rias `tools` (fun√ß√µes Python que interagem com APIs externas). Essa fun√ß√£o do LangChain permite que o LLM, ao receber a instru√ß√£o inicial ("colete os dados sobre o mercado de Bitcoin"), analise as ferramentas dispon√≠veis e decida quais delas chamar e com quais argumentos. Ap√≥s as ferramentas retornarem seus resultados, usamos `llm.with_structured_output(StructuredJsonOutput)` para instruir o LLM a consolidar todas as informa√ß√µes coletadas em um √∫nico objeto **JSON estruturado**. Isso garante que a sa√≠da do Data Fetcher seja consistente e f√°cil de processar pelo pr√≥ximo agente.

### Agente 2: Data Analyst (O Int√©rprete)

<center>

<div style="width: 90%;">
<img src="/post/2025-05-04-bitcoin-agent/02.png" alt="data analyst agent" style="width: 100%;">
</div> 
<p style="text-align: center; font-style: italic;">Fluxo de trabalho do Data Analyst</p>

</center>

<details>
<summary>*Ver c√≥digo*</summary>
```{python}
from langgraph.func import task
from langchain.prompts import ChatPromptTemplate, FewShotChatMessagePromptTemplate
from langchain_openai import ChatOpenAI

from prompts.data_analyst_example import input_example, output_example

llm = ChatOpenAI(model="gpt-4", temperature=0.7)

@task
def data_analyst(report: str):

  input = f"""
  Voc√™ √© um analista financeiro experiente em Cryptomoedas e especialista em Bitcoin.
  Analise as tend√™ncias do cen√°rio do Bitcoin hoje com base no json \
  delimitado por tr√™s crases (```):

  \```
  {report}
  \```

  Siga rigorosamente as instru√ß√µes abaixo:

  - ...
  """

  examples = [
      {"input": input_example, "output": output_example},
       ]

  example_prompt = ChatPromptTemplate.from_messages([
      ("human", "{input}"),
      ("ai", "{output}"),
      ])

  few_shot_prompt = FewShotChatMessagePromptTemplate(
      example_prompt=example_prompt,
      examples=examples,
      )

  prompt_system = "Voc√™ √© um analista financeiro experiente em Criptomoedas e especialista em Bitcoin."

  final_prompt = ChatPromptTemplate.from_messages([
    ("system", prompt_system),
    few_shot_prompt,
    ("human", "{input}"),
    ])

  chain = final_prompt | llm

  msg = chain.invoke(input=input)

  return msg.content
```

</details>

*   **Objetivo**: Receber o JSON de dados brutos do Data Fetcher e transform√°-lo em um relat√≥rio anal√≠tico coeso, formatado em Markdown, interpretando cada indicador e explicando seu poss√≠vel impacto.
*   **Prompt Engineering em A√ß√£o**: Este agente √© um √≥timo exemplo de como guiar um LLM para tarefas complexas de formata√ß√£o e interpreta√ß√£o.
    *   **Instru√ß√µes Detalhadas**: O prompt define explicitamente o papel do agente ("analista financeiro experiente"), o formato desejado (Markdown, bullet points, negrito), o tom ("equilibrado e menos t√©cnico"), e regras espec√≠ficas (mencionar pre√ßos em USD e BRL, usar sinal de menos para varia√ß√µes negativas, seguir a estrutura do exemplo).
    *   **Estrat√©gia Few-Shot**: Para garantir que o LLM siga o formato e o estilo de interpreta√ß√£o desejados, utilizamos a t√©cnica Few-Shot (semelhante como fiz em um [post anterior](https://gomesfellipe.github.io/post/2024-05-26-detec-o-de-linguagem-t-xica-com-o-llm-gemma-e-langchain/)). Fornecemos um exemplo completo de um input (um JSON de dados similar ao que o Data Fetcher produziria) e o output correspondente (o relat√≥rio em Markdown formatado e interpretado). Isso √© feito usando `FewShotChatMessagePromptTemplate` do LangChain, que insere o exemplo diretamente no contexto do prompt final.
    *   **Cadeia LCEL**: O prompt final √© constru√≠do usando a LangChain Expression Language (LCEL), combinando o prompt do sistema (definindo o papel), o prompt Few-Shot (com o exemplo) e o prompt humano (contendo as instru√ß√µes e o JSON de dados brutos atual).

### Agente 3: Market Strategist (O Conselheiro)

<center>

<div style="width: 80%;">
<img src="/post/2025-05-04-bitcoin-agent/03.png" alt="market strategist agent" style="width: 100%;">
</div> 
<p style="text-align: center; font-style: italic;">Fluxo de trabalho do Market Strategist</p>

</center>

<details>
<summary>*Ver c√≥digo*</summary>
```{python}
from langgraph.func import task
from langchain.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(temperature=0.7)

@task
def market_strategist(analyst_report: str):
    """
    Gera recomenda√ß√µes de posicionamento com base na an√°lise do Data Analyst.
    """
  
    input = f"""
    Seu papel √© analisar o relat√≥rio t√©cnico fornecido no formatado em Markdown e transformar\
    em uma s√≠ntese estrat√©gica e executiva, com alertas, insights e orienta√ß√µes t√°ticas de alto n√≠vel.
  
    \``` markdown
    {analyst_report}
    \```
  
    Siga rigorosamente as instru√ß√µes abaixo:
  
    - ...
    """
  
    prompt = ChatPromptTemplate.from_messages([
        ("system", "Voc√™ √© um estrategista de mercado s√™nior, com ampla experi√™ncia em ativos digitais e especializa√ß√£o em Bitcoin."),
        ("human", "{input}")
    ])
  
    chain = prompt | llm
    msg = chain.invoke(input=input)
    return msg.content

```

</details>

*   **Objetivo**: Ler o relat√≥rio t√©cnico detalhado do Data Analyst e interpretar as informa√ß√µes em uma s√≠ntese estrat√©gica e executiva. O foco √© identificar a tend√™ncia geral, destacar sinais chave e fornecer recomenda√ß√µes t√°ticas claras.
*   **Prompt**: O prompt para este agente √© crucial para mudar o n√≠vel da an√°lise. Ele instrui o LLM a agir como um "estrategista de mercado s√™nior", focando em:
    *   **Resumo**: Extrair os pontos mais cr√≠ticos.
    *   **Tend√™ncia**: Classificar o mercado (alta, baixa, neutro).
    *   **Sinais**: Identificar indicadores de otimismo ou cautela.
    *   **Recomenda√ß√µes**: Gerar orienta√ß√µes pr√°ticas e acion√°veis ("isso indica que...", "logo, √© prudente...").
    *   **Racioc√≠nio**: Explicitar o processo de pensamento com **CoT** (**Chain-of-Thought**) que levou √†s conclus√µes antes de apresentar a s√≠ntese final.
    *   **Tom**: Consultivo, direto e profissional.

### Agente 4: Client Manager (O Porteiro)

<center>

<div style="width: 80%;">
<img src="/post/2025-05-04-bitcoin-agent/04.png" alt="client manager agent" style="width: 100%;">
</div> 
<p style="text-align: center; font-style: italic;">Fluxo de trabalho do Client Manager</p>

</center>

<details>
<summary>*Ver c√≥digo*</summary>
```{python}
from langgraph.func import task
from langchain.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(temperature=0.7)

@task
def client_manager(final_report: str):
    """
    Avalia o relat√≥rio estrat√©gico e decide se deve ou n√£o alertar o cliente.
    A decis√£o final √© bin√°ria: ALERTAR_CLIENTE ou N√ÉO_ALERTAR.
    """

    input = f"""
    Objetivo do cliente: Acumular Bitcoins no longo prazo, investindo mensalmente nas melhores janelas de oportunidade.

    Seu papel √© avaliar o relat√≥rio abaixo e decidir se h√° motivos suficientes para alertar o cliente:

    \``` markdown
    {final_report}
    \```

    Siga rigorosamente as instru√ß√µes abaixo:

    - ...
    """

    prompt = ChatPromptTemplate.from_messages([
        ("system", "Voc√™ √© um Client Manager, especializado em comunica√ß√£o estrat√©gica com clientes de alto valor."),
        ("human", "{input}")
    ])

    chain = prompt | llm
    msg = chain.invoke(input=input)
    return msg.content


```

</details>

*   **Objetivo**: Avaliar a s√≠ntese estrat√©gica do Market Strategist √† luz do objetivo espec√≠fico do cliente (acumula√ß√£o de longo prazo) e tomar uma decis√£o bin√°ria: a situa√ß√£o atual justifica um alerta ou n√£o?
*   **Prompt**: Este prompt √© focado na tomada de decis√£o.
    *   **Contexto do Cliente**: Define claramente o objetivo ("Acumular Bitcoins no longo prazo, investindo mensalmente nas melhores janelas de oportunidade.").
    *   **Crit√©rios de Alerta**: Especifica o que procurar (mudan√ßa relevante de tend√™ncia, risco/oportunidade claros, indicadores extremos, recomenda√ß√µes urgentes).
    *   **Racioc√≠nio Obrigat√≥rio**: Exige que o agente explique seu processo de pensamento **CoT** (**Chain-of-Thought**) antes da decis√£o final.
    *   **Output Bin√°rio**: A resposta final deve ser *apenas* a palavra `ALERTAR` ou `N√ÉO_ALERTAR` em mai√∫sculas, precedida pelo racioc√≠nio.

## Desafios, Aprendizados e Observabilidade

Construir agentes envolve desafios:

*   **Prompt Engineering**: √â uma arte iterativa. Clareza, exemplos (Few-Shot) e estrutura s√£o essenciais.
*   **Orquestra√ß√£o (LangGraph)**: Gerenciar o estado e o fluxo entre n√≥s exige aten√ß√£o.
*   **Integra√ß√£o de Ferramentas**: Descri√ß√µes claras das `tools` s√£o vitais para o LLM us√°-las corretamente.
*   **Observabilidade**: Identificar falhas em fluxos complexos pode ser dif√≠cil. 

Ferramentas como o **LangSmith** s√£o extremamente √∫teis na monitoramento dos agentes, permitindo rastrear e depurar cada passo de sua execu√ß√£o, chamadas de LLM e uso de ferramentas. Ele oferece uma vis√£o clara do que est√° acontecendo "por baixo dos panos", facilitando a identifica√ß√£o de gargalos ou erros.

<center>

<div style="width: 90%;">
<img src="/post/2025-05-04-bitcoin-agent/langsmith-exemplo.png" alt="langsmith" style="width: 100%;">
</div> 
<p style="text-align: center; font-style: italic;">Print da tela do LangSmith do projeto</p>

</center>

## Conclus√£o

Criamos uma equipe de agentes IA capaz de automatizar a complexa an√°lise do mercado Bitcoin, usando LangChain e LangGraph para orquestra√ß√£o. O sistema coleta dados, interpreta, gera estrat√©gias e decide sobre alertas, transformando dados brutos em insights acion√°veis. Veja como √© o alerta recebido no Telegram:

<div style="display: flex; justify-content: space-between; align-items: center;">

<center>

  <img src="/post/2025-05-04-bitcoin-agent/telegram1.PNG" alt="Report no Telegram 1" style="width: 80%;">

</center>

<center>

  <img src="/post/2025-05-04-bitcoin-agent/telegram2.PNG" alt="Report no Telegram 2" style="width: 80%;">
  
</center>
  
</div>
<p style="text-align: center; font-style: italic;">Print das telas do bot no Telegram.</p>

Este projeto demonstra o potencial dos agentes para automatizar tarefas repetitivas que envolvem a tomada de decis√µes com um certo "racioc√≠nio". Os pr√≥ximos passos podem envolver refinar prompts, adicionar mais ferramentas, integrar mais visualiza√ß√µes ou implementar notifica√ß√µes ativas.



## Refer√™ncias

*   [LangChain - Documenta√ß√£o](https://python.langchain.com/)
*   [LangGraph - Documenta√ß√£o](https://langchain-ai.github.io/langgraph/)
*   [LangSmith - Documenta√ß√£o](https://smith.langchain.com/)
*   [OpenAI API Plataform](https://openai.com/api/)
*   [OpenAI - Prompt Engineering Guide](https://github.com/openai/openai-cookbook/blob/main/examples/gpt4-1_prompting_guide.ipynb)
*   [OpenAI - A Practical Guide to Building Agents](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf)
*   [LangGraph Tutorial - Building Agentic Workflows](https://langchain-ai.github.io/langgraph/tutorials/workflows/)
*   [LangChain Blog - How to think about agent frameworks](https://blog.langchain.dev/how-to-think-about-agent-frameworks/)

